Given a binary tree, return the level order traversal of its nodes' values. (ie, from left to right, level by level).

For example:
Given binary tree [3,9,20,null,null,15,7],
    3
   / \
  9  20
    /  \
   15   7
return its level order traversal as:
[
  [3],
  [9,20],
  [15,7]
]

Solution:

# Definition for a binary tree node.
# class TreeNode(object):
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution(object):
    def levelOrder(self, root):
        """
        :type root: TreeNode
        :rtype: List[List[int]]
        """
        if root == None:
            return
        queue = [(root,0)]
        result = []
        curr_level = []
        prev_level = 0
        
        
        while len(queue) > 0:
            node,level = queue.pop(0)
            if node == None:
                continue
            if level > prev_level:
                result.append(curr_level[:])
                curr_level = []
                prev_level = level
            curr_level.append(node.val)
            queue.append((node.left, level + 1))
            queue.append((node.right, level + 1))
        
        if root != None:
            result.append(curr_level[:])
  
        return(result)

Given a binary tree, return the zigzag level order traversal of its nodes' values. (ie, from left to right, then right to left for the next level and alternate between).

For example:
Given binary tree [3,9,20,null,null,15,7],
    3
   / \
  9  20
    /  \
   15   7
return its zigzag level order traversal as:
[
  [3],
  [20,9],
  [15,7]
]

Solution:

# Definition for a binary tree node.
# class TreeNode(object):
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution(object):
    def zigzagLevelOrder(self, root):
        """
        :type root: TreeNode
        :rtype: List[List[int]]
        """
        if root == None:
            return
        queue = [(root,0)]
        result = []
        curr_level = []
        prev_level = 0
        ctr = 1
        
        while len(queue) > 0:
            node,level = queue.pop(0)
            if node == None:
                continue
            if level > prev_level:
                if ctr % 2 == 0:
                    result.append(curr_level[::-1])
                else:
                    result.append(curr_level[:])
                curr_level = []
                prev_level = level
                ctr += 1
            curr_level.append(node.val)
            queue.append((node.left, level + 1))
            queue.append((node.right, level + 1))
        
        if root != None and ctr % 2 == 0:
            result.append(curr_level[::-1])
        else:
            result.append(curr_level[:])
  
        return(result)

Given preorder and inorder traversal of a tree, construct the binary tree.

Note:
You may assume that duplicates do not exist in the tree.

For example, given

preorder = [3,9,20,15,7]
inorder = [9,3,15,20,7]
Return the following binary tree:

    3
   / \
  9  20
    /  \
   15   7

Solution:

# Definition for a binary tree node.
# class TreeNode(object):
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution(object):
    def buildTree(self, preorder, inorder):
        """
        :type preorder: List[int]
        :type inorder: List[int]
        :rtype: TreeNode
        """
        if len(preorder) == 0:
            return None
        # first element in predorder is root, then find the root index in inorder
        # whatever comes before root in inorder is left subtree
        # whatever comes after root in inorder is right subtree
        # do this recirsively 
        root = TreeNode(preorder[0])
        inorder_root_idx = inorder.index(preorder[0])
        left_len = inorder_root_idx
        root.left = self.buildTree(preorder[1:(1+left_len)], inorder[0:inorder_root_idx])
        root.right = self.buildTree(preorder[1+left_len:], inorder[inorder_root_idx+1:])
        return(root)

Given inorder and postorder traversal of a tree, construct the binary tree.

Note:
You may assume that duplicates do not exist in the tree.

For example, given

inorder = [9,3,15,20,7]
postorder = [9,15,7,20,3]
Return the following binary tree:

    3
   / \
  9  20
    /  \
   15   7

Solution:

# Definition for a binary tree node.
# class TreeNode(object):
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution(object):
    def buildTree(self, inorder, postorder):
        """
        :type inorder: List[int]
        :type postorder: List[int]
        :rtype: TreeNode
        """
        if len(postorder) == 0:
            return None
        root = TreeNode(postorder[len(postorder) - 1])
        inorder_root_idx = inorder.index(postorder[-1])
        root.left = self.buildTree(inorder[0:inorder_root_idx],postorder[:inorder_root_idx])
        root.right = self.buildTree( inorder[inorder_root_idx+1:],postorder[inorder_root_idx:-1])
        return(root)

Given a singly linked list where elements are sorted in ascending order, convert it to a height balanced BST.

For this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differ by more than 1.

Example:

Given the sorted linked list: [-10,-3,0,5,9],

One possible answer is: [0,-3,9,-10,null,5], which represents the following height balanced BST:

      0
     / \
   -3   9
   /   /
 -10  5   

Solution:

# Definition for singly-linked list.
# class ListNode(object):
#     def __init__(self, x):
#         self.val = x
#         self.next = None

# Definition for a binary tree node.
# class TreeNode(object):
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution(object):
    def sortedListToBST(self, head):
        """
        :type head: ListNode
        :rtype: TreeNode
        """
        if head == None:
            return
        if head.next == None:
            return(TreeNode(head.val))
        lst = []
        while(head != None):
            lst.append(head.val)
            head = head.next
        return(self.buildBST(lst, 0, len(lst) - 1, (len(lst) - 1 )/ 2 ))
    
    def buildBST(self,lst,start, end, index):
        if(start > end):
            return
        node = TreeNode(lst[index])
        node.left = self.buildBST(lst, start, index - 1, (start + index -1)/ 2)
        node.right = self.buildBST(lst, index + 1, end, (index + 1 + end)/ 2)
        return(node)


Given a binary tree and a sum, find all root-to-leaf paths where each path's sum equals the given sum.

Note: A leaf is a node with no children.

Example:

Given the below binary tree and sum = 22,

      5
     / \
    4   8
   /   / \
  11  13  4
 /  \    / \
7    2  5   1
Return:

[
   [5,4,11,2],
   [5,8,4,5]
]

Solution:
# Definition for a binary tree node.
# class TreeNode(object):
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution(object):
    def pathSum(self, root, sum):
        """
        :type root: TreeNode
        :type sum: int
        :rtype: List[List[int]]
        """
        result = []
        path = []
        n = 0
        self.dfs(root,n,sum, result, list(path))
        return(result)
        
    def dfs(self, node,currSum, Sum, result, path):
        if node == None:
            return
        path.append(node.val)
        currSum += node.val
        if(node.left == None and node.right == None):
            if(currSum == Sum):
                result.append(path)
        else:
            if node.left:
                self.dfs(node.left,currSum, Sum, result, list(path))
            if node.right:
                self.dfs(node.right,currSum, Sum, result,list(path))


Given a triangle, find the minimum path sum from top to bottom. Each step you may move to adjacent numbers on the row below.

For example, given the following triangle

[
     [2],
    [3,4],
   [6,5,7],
  [4,1,8,3]
]
The minimum path sum from top to bottom is 11 (i.e., 2 + 3 + 5 + 1 = 11).

Solution:
class Solution(object):
    def minimumTotal(self, triangle):
        """
        :type triangle: List[List[int]]
        :rtype: int
        """
        for i in range(1, len(triangle)):
            for j in range(len(triangle[i])):
                if j == 0:
                    triangle[i][0] += triangle[i - 1][0]
                elif j == len(triangle[i]) - 1:
                    triangle[i][j] += triangle[i - 1][-1]
                else:
                    triangle[i][j] += min(triangle[i - 1][j-1], triangle[i - 1][j])
        return(min(triangle[-1]))

Given a non-empty array of integers, every element appears three times except for one, which appears exactly once. Find that single one.

Example 1:

Input: [2,2,3,2]
Output: 3
Example 2:

Input: [0,1,0,1,0,1,99]
Output: 99

Solution: 
class Solution(object):
    def singleNumber(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        record = {}
        for i in nums:
            if i not in record.keys():
                record[i] = 1
            else:
                record[i] += 1
        for i, freq in record.items():
            if freq == 1:
                return(i)        

